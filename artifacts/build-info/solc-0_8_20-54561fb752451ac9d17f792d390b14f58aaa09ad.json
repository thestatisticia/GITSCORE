{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-54561fb752451ac9d17f792d390b14f58aaa09ad",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/GitHubScorer.sol": "project/contracts/GitHubScorer.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/GitHubScorer.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title GitHubScorer\n * @dev Smart contract for storing GitHub profile scores on Flare Testnet\n * Integrates with Flare Data Connector (FDC) for verified data\n */\ncontract GitHubScorer {\n    // Structure to store score data\n    struct ScoreData {\n        uint256 score;\n        uint256 timestamp;\n        bool fdcVerified; // Flag to indicate if score was verified via FDC\n        bytes32 fdcAttestationId; // FDC attestation ID for verification\n    }\n    \n    // Mapping: walletAddress => githubUsername => ScoreData\n    mapping(address => mapping(string => ScoreData)) public scores;\n    \n    // Mapping: walletAddress => latest githubUsername\n    mapping(address => string) public userLatestUsername;\n    \n    // Array to track all wallet addresses that have stored scores (for leaderboard)\n    address[] public scoreAddresses;\n    mapping(address => bool) public hasStoredScore;\n    \n    // FDC verification: mapping from attestation ID to score data\n    mapping(bytes32 => bool) public fdcAttestations;\n    \n    // Owner/admin address (can be set during deployment)\n    address public owner;\n    \n    // Events\n    event ScoreStored(\n        address indexed walletAddress,\n        string indexed githubUsername,\n        uint256 score,\n        uint256 timestamp,\n        bool fdcVerified,\n        bytes32 fdcAttestationId\n    );\n    \n    event FdcScoreStored(\n        address indexed walletAddress,\n        string indexed githubUsername,\n        uint256 score,\n        bytes32 indexed fdcAttestationId\n    );\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n    \n    constructor() {\n        owner = msg.sender;\n    }\n    \n    /**\n     * @dev Store a GitHub score for a wallet address (standard method)\n     * @param walletAddress The wallet address storing the score\n     * @param githubUsername The GitHub username\n     * @param score The calculated score (0-1000)\n     * @param timestamp The timestamp when score was calculated\n     */\n    function storeScore(\n        address walletAddress,\n        string memory githubUsername,\n        uint256 score,\n        uint256 timestamp\n    ) public {\n        require(bytes(githubUsername).length > 0, \"GitHub username cannot be empty\");\n        require(score <= 1000, \"Score must be between 0 and 1000\");\n        \n        scores[walletAddress][githubUsername] = ScoreData({\n            score: score,\n            timestamp: timestamp,\n            fdcVerified: false,\n            fdcAttestationId: bytes32(0)\n        });\n        \n        userLatestUsername[walletAddress] = githubUsername;\n        \n        // Track address for leaderboard\n        if (!hasStoredScore[walletAddress]) {\n            scoreAddresses.push(walletAddress);\n            hasStoredScore[walletAddress] = true;\n        }\n        \n        emit ScoreStored(walletAddress, githubUsername, score, timestamp, false, bytes32(0));\n    }\n    \n    /**\n     * @dev Store a GitHub score verified via Flare Data Connector (FDC)\n     * @param walletAddress The wallet address storing the score\n     * @param githubUsername The GitHub username\n     * @param score The calculated score (0-1000) - verified by FDC\n     * @param timestamp The timestamp when score was calculated\n     * @param fdcAttestationId The FDC attestation ID for this verified data\n     */\n    function storeFdcVerifiedScore(\n        address walletAddress,\n        string memory githubUsername,\n        uint256 score,\n        uint256 timestamp,\n        bytes32 fdcAttestationId\n    ) public onlyOwner {\n        require(bytes(githubUsername).length > 0, \"GitHub username cannot be empty\");\n        require(score <= 1000, \"Score must be between 0 and 1000\");\n        require(fdcAttestationId != bytes32(0), \"FDC attestation ID cannot be zero\");\n        require(!fdcAttestations[fdcAttestationId], \"FDC attestation already used\");\n        \n        // Mark attestation as used\n        fdcAttestations[fdcAttestationId] = true;\n        \n        scores[walletAddress][githubUsername] = ScoreData({\n            score: score,\n            timestamp: timestamp,\n            fdcVerified: true,\n            fdcAttestationId: fdcAttestationId\n        });\n        \n        userLatestUsername[walletAddress] = githubUsername;\n        \n        // Track address for leaderboard\n        if (!hasStoredScore[walletAddress]) {\n            scoreAddresses.push(walletAddress);\n            hasStoredScore[walletAddress] = true;\n        }\n        \n        emit ScoreStored(walletAddress, githubUsername, score, timestamp, true, fdcAttestationId);\n        emit FdcScoreStored(walletAddress, githubUsername, score, fdcAttestationId);\n    }\n    \n    /**\n     * @dev Get score for a specific wallet and GitHub username\n     * @param walletAddress The wallet address\n     * @param githubUsername The GitHub username\n     * @return score The stored score\n     * @return timestamp The timestamp when score was stored\n     */\n    function getScore(\n        address walletAddress,\n        string memory githubUsername\n    ) public view returns (uint256 score, uint256 timestamp) {\n        ScoreData memory data = scores[walletAddress][githubUsername];\n        return (data.score, data.timestamp);\n    }\n    \n    /**\n     * @dev Get the latest score for a wallet address\n     * @param walletAddress The wallet address\n     * @return githubUsername The GitHub username\n     * @return score The stored score\n     * @return timestamp The timestamp when score was stored\n     */\n    function getUserLatestScore(\n        address walletAddress\n    ) public view returns (string memory githubUsername, uint256 score, uint256 timestamp) {\n        string memory username = userLatestUsername[walletAddress];\n        require(bytes(username).length > 0, \"No score found for this wallet\");\n        \n        ScoreData memory data = scores[walletAddress][username];\n        return (username, data.score, data.timestamp);\n    }\n    \n    /**\n     * @dev Check if a score exists for a wallet and GitHub username\n     * @param walletAddress The wallet address\n     * @param githubUsername The GitHub username\n     * @return exists True if score exists\n     */\n    function scoreExists(\n        address walletAddress,\n        string memory githubUsername\n    ) public view returns (bool exists) {\n        return scores[walletAddress][githubUsername].timestamp > 0;\n    }\n    \n    /**\n     * @dev Get total number of addresses with stored scores\n     * @return count Total number of addresses\n     */\n    function getScoreAddressesCount() public view returns (uint256 count) {\n        return scoreAddresses.length;\n    }\n    \n    /**\n     * @dev Get address at index (for leaderboard iteration)\n     * @param index The index in the scoreAddresses array\n     * @return walletAddress The wallet address\n     */\n    function getScoreAddress(uint256 index) public view returns (address walletAddress) {\n        require(index < scoreAddresses.length, \"Index out of bounds\");\n        return scoreAddresses[index];\n    }\n    \n    /**\n     * @dev Check if a score is FDC verified\n     * @param walletAddress The wallet address\n     * @param githubUsername The GitHub username\n     * @return verified True if score is FDC verified\n     * @return attestationId The FDC attestation ID if verified\n     */\n    function isFdcVerified(\n        address walletAddress,\n        string memory githubUsername\n    ) public view returns (bool verified, bytes32 attestationId) {\n        ScoreData memory data = scores[walletAddress][githubUsername];\n        return (data.fdcVerified, data.fdcAttestationId);\n    }\n}\n\n"
      }
    }
  }
}